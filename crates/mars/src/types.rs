/// Core types for the MARS (Multi-Agent Reasoning System) implementation.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// A solution generated by an agent.
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Solution {
    /// Unique identifier for this solution
    pub id: String,
    /// Agent ID that generated this solution
    pub agent_id: String,
    /// The reasoning/thinking process
    pub reasoning: String,
    /// The final answer
    pub answer: String,
    /// Temperature used to generate this solution
    pub temperature: f32,
    /// Token count used
    pub token_count: usize,
    /// Timestamp when created
    pub created_at: DateTime<Utc>,
    /// Number of verification passes this solution has received
    pub verification_passes: usize,
    /// Number of verification failures this solution has received
    pub verification_failures: usize,
    /// Whether this solution has been verified as correct
    pub is_verified: bool,
    /// Score from verification (0.0-1.0)
    pub verification_score: f32,
    /// Generation phase (initial, aggregated, improved, etc.)
    pub phase: GenerationPhase,
}

impl Solution {
    /// Create a new solution
    pub fn new(
        agent_id: String,
        reasoning: String,
        answer: String,
        temperature: f32,
        token_count: usize,
    ) -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            agent_id,
            reasoning,
            answer,
            temperature,
            token_count,
            created_at: Utc::now(),
            verification_passes: 0,
            verification_failures: 0,
            is_verified: false,
            verification_score: 0.0,
            phase: GenerationPhase::Initial,
        }
    }

    /// Update verification status
    pub fn add_verification_pass(&mut self, score: f32) {
        self.verification_passes += 1;
        self.verification_score = (self.verification_score + score) / 2.0;
        // Mark as verified after 2 consecutive passes
        if self.verification_passes >= 2 && self.verification_failures == 0 {
            self.is_verified = true;
        }
    }

    /// Record a verification failure
    pub fn add_verification_failure(&mut self) {
        self.verification_failures += 1;
        self.is_verified = false;
    }
}

/// Phase in which the solution was generated
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq)]
pub enum GenerationPhase {
    /// Initial generation from agents
    Initial,
    /// Generated through aggregation
    Aggregated,
    /// Improved based on feedback
    Improved,
    /// Synthesized from multiple solutions
    Synthesized,
}

/// Result of verifying a solution
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct VerificationResult {
    /// Solution ID that was verified
    pub solution_id: String,
    /// Whether the verification passed
    pub is_correct: bool,
    /// Numerical score (0.0-1.0)
    pub score: f32,
    /// Feedback on correctness
    pub correctness_feedback: String,
    /// Feedback on completeness
    pub completeness_feedback: String,
    /// Feedback on rigor
    pub rigor_feedback: String,
    /// Verifying agent ID
    pub verifying_agent_id: String,
    /// Timestamp of verification
    pub verified_at: DateTime<Utc>,
}

impl VerificationResult {
    /// Create a new verification result
    pub fn new(
        solution_id: String,
        is_correct: bool,
        score: f32,
        verifying_agent_id: String,
    ) -> Self {
        Self {
            solution_id,
            is_correct,
            score,
            correctness_feedback: String::new(),
            completeness_feedback: String::new(),
            rigor_feedback: String::new(),
            verifying_agent_id,
            verified_at: Utc::now(),
        }
    }
}

/// Aggregation result combining multiple solutions
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct AggregationResult {
    /// Solutions that were aggregated
    pub source_solution_ids: Vec<String>,
    /// The synthesized solution
    pub synthesized_solution: Solution,
    /// Aggregation method used
    pub method: AggregationMethod,
}

/// Method used for aggregating solutions
#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum AggregationMethod {
    /// RSA-inspired aggregation
    RSA,
    /// Majority voting
    MajorityVoting,
    /// Best-of-N selection
    BestOfN,
    /// Mixture of experts
    MixtureOfExperts,
    /// Mixture of Agents (MOA) - generates diverse completions and synthesizes
    MixtureOfAgents,
    /// Monte Carlo Tree Search - explores reasoning tree with UCB selection
    MonteCarloTreeSearch,
}

/// Strategy extracted from a solution
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Strategy {
    /// Unique identifier
    pub id: String,
    /// Brief description of the strategy
    pub description: String,
    /// The actual technique/prompt
    pub technique: String,
    /// Agent ID that discovered this strategy
    pub discovered_by: String,
    /// Success rate of this strategy
    pub success_rate: f32,
    /// Timestamp when discovered
    pub discovered_at: DateTime<Utc>,
}

/// Final output from MARS
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct MarsOutput {
    /// The final best answer
    pub answer: String,
    /// Reasoning leading to the answer
    pub reasoning: String,
    /// All solutions generated
    pub all_solutions: Vec<Solution>,
    /// All verification results
    pub verifications: Vec<VerificationResult>,
    /// Final selected solution ID
    pub final_solution_id: String,
    /// Selection method used
    pub selection_method: SelectionMethod,
    /// Number of iterations performed
    pub iterations: usize,
    /// Total tokens used
    pub total_tokens: usize,
    /// Timestamp when completed
    pub completed_at: DateTime<Utc>,
}

/// Method used to select the final answer
#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum SelectionMethod {
    /// Selected via majority voting
    MajorityVoting,
    /// Selected as best verified solution
    BestVerified,
    /// Synthesized from top solutions
    Synthesized,
    /// Manual selection
    Manual,
}

/// Event emitted during MARS execution for progress tracking
#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum MarsEvent {
    /// Initial exploration phase started with given number of agents
    ExplorationStarted {
        /// Number of agents participating in exploration
        num_agents: usize
    },
    /// Agent generated a solution
    SolutionGenerated {
        /// Unique identifier for the generated solution
        solution_id: String,
        /// Identifier of the agent that generated the solution
        agent_id: String
    },
    /// Verification phase started
    VerificationStarted,
    /// Solution was verified with results
    SolutionVerified {
        /// Unique identifier for the solution
        solution_id: String,
        /// Whether the solution passed verification
        is_correct: bool,
        /// Verification score (0.0 to 1.0)
        score: f32,
    },
    /// Aggregation phase started
    AggregationStarted,
    /// Solutions were aggregated into a result
    SolutionsAggregated {
        /// Identifier of the aggregated solution
        result_solution_id: String
    },
    /// Improvement phase started at specified iteration
    ImprovementStarted {
        /// Current improvement iteration number
        iteration: usize
    },
    /// Solution was improved
    SolutionImproved {
        /// Identifier of the improved solution
        solution_id: String
    },
    /// Strategy network phase started
    StrategyNetworkStarted,
    /// Strategy was extracted from solutions
    StrategyExtracted {
        /// Identifier of the extracted strategy
        strategy_id: String
    },
    /// Synthesis phase started
    SynthesisStarted,
    /// Final answer synthesized from verified solutions
    AnswerSynthesized {
        /// The synthesized answer string
        answer: String
    },
    /// MARS execution completed successfully
    Completed {
        /// Final answer produced by MARS
        final_answer: String,
        /// Method used to generate the final answer
        method: String
    },
    /// Error occurred during execution
    Error {
        /// Error message describing what went wrong
        message: String
    },
}
