/// Core types for the MARS (Multi-Agent Reasoning System) implementation.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// A solution generated by an agent.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Solution {
    /// Unique identifier for this solution
    pub id: String,
    /// Agent ID that generated this solution
    pub agent_id: String,
    /// The reasoning/thinking process
    pub reasoning: String,
    /// The final answer
    pub answer: String,
    /// Temperature used to generate this solution
    pub temperature: f32,
    /// Token count used
    pub token_count: usize,
    /// Timestamp when created
    pub created_at: DateTime<Utc>,
    /// Number of verification passes this solution has received
    pub verification_passes: usize,
    /// Number of verification failures this solution has received
    pub verification_failures: usize,
    /// Whether this solution has been verified as correct
    pub is_verified: bool,
    /// Score from verification (0.0-1.0)
    pub verification_score: f32,
    /// Generation phase (initial, aggregated, improved, etc.)
    pub phase: GenerationPhase,
}

impl Solution {
    /// Create a new solution
    pub fn new(
        agent_id: String,
        reasoning: String,
        answer: String,
        temperature: f32,
        token_count: usize,
    ) -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            agent_id,
            reasoning,
            answer,
            temperature,
            token_count,
            created_at: Utc::now(),
            verification_passes: 0,
            verification_failures: 0,
            is_verified: false,
            verification_score: 0.0,
            phase: GenerationPhase::Initial,
        }
    }

    /// Update verification status
    pub fn add_verification_pass(&mut self, score: f32) {
        self.verification_passes += 1;
        self.verification_score = (self.verification_score + score) / 2.0;
        // Mark as verified after 2 consecutive passes
        if self.verification_passes >= 2 && self.verification_failures == 0 {
            self.is_verified = true;
        }
    }

    /// Record a verification failure
    pub fn add_verification_failure(&mut self) {
        self.verification_failures += 1;
        self.is_verified = false;
    }
}

/// Phase in which the solution was generated
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq)]
pub enum GenerationPhase {
    /// Initial generation from agents
    Initial,
    /// Generated through aggregation
    Aggregated,
    /// Improved based on feedback
    Improved,
    /// Synthesized from multiple solutions
    Synthesized,
}

/// Result of verifying a solution
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct VerificationResult {
    /// Solution ID that was verified
    pub solution_id: String,
    /// Whether the verification passed
    pub is_correct: bool,
    /// Numerical score (0.0-1.0)
    pub score: f32,
    /// Feedback on correctness
    pub correctness_feedback: String,
    /// Feedback on completeness
    pub completeness_feedback: String,
    /// Feedback on rigor
    pub rigor_feedback: String,
    /// Verifying agent ID
    pub verifying_agent_id: String,
    /// Timestamp of verification
    pub verified_at: DateTime<Utc>,
}

impl VerificationResult {
    /// Create a new verification result
    pub fn new(
        solution_id: String,
        is_correct: bool,
        score: f32,
        verifying_agent_id: String,
    ) -> Self {
        Self {
            solution_id,
            is_correct,
            score,
            correctness_feedback: String::new(),
            completeness_feedback: String::new(),
            rigor_feedback: String::new(),
            verifying_agent_id,
            verified_at: Utc::now(),
        }
    }
}

/// Aggregation result combining multiple solutions
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct AggregationResult {
    /// Solutions that were aggregated
    pub source_solution_ids: Vec<String>,
    /// The synthesized solution
    pub synthesized_solution: Solution,
    /// Aggregation method used
    pub method: AggregationMethod,
}

/// Method used for aggregating solutions
#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum AggregationMethod {
    /// RSA-inspired aggregation
    RSA,
    /// Majority voting
    MajorityVoting,
    /// Best-of-N selection
    BestOfN,
    /// Mixture of experts
    MixtureOfExperts,
    /// Mixture of Agents (MOA) - generates diverse completions and synthesizes
    MixtureOfAgents,
    /// Monte Carlo Tree Search - explores reasoning tree with UCB selection
    MonteCarloTreeSearch,
}

/// Strategy extracted from a solution
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Strategy {
    /// Unique identifier
    pub id: String,
    /// Brief description of the strategy
    pub description: String,
    /// The actual technique/prompt
    pub technique: String,
    /// Agent ID that discovered this strategy
    pub discovered_by: String,
    /// Success rate of this strategy
    pub success_rate: f32,
    /// Timestamp when discovered
    pub discovered_at: DateTime<Utc>,
}

/// Final output from MARS
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct MarsOutput {
    /// The final best answer
    pub answer: String,
    /// Reasoning leading to the answer
    pub reasoning: String,
    /// All solutions generated
    pub all_solutions: Vec<Solution>,
    /// All verification results
    pub verifications: Vec<VerificationResult>,
    /// Final selected solution ID
    pub final_solution_id: String,
    /// Selection method used
    pub selection_method: SelectionMethod,
    /// Number of iterations performed
    pub iterations: usize,
    /// Total tokens used
    pub total_tokens: usize,
    /// Timestamp when completed
    pub completed_at: DateTime<Utc>,
}

/// Method used to select the final answer
#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum SelectionMethod {
    /// Selected via majority voting
    MajorityVoting,
    /// Selected as best verified solution
    BestVerified,
    /// Synthesized from top solutions
    Synthesized,
    /// Manual selection
    Manual,
}

/// Event emitted during MARS execution for progress tracking
#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum MarsEvent {
    /// Initial exploration phase started
    ExplorationStarted { num_agents: usize },
    /// Agent generated a solution
    SolutionGenerated { solution_id: String, agent_id: String },
    /// Verification phase started
    VerificationStarted,
    /// Solution was verified
    SolutionVerified {
        solution_id: String,
        is_correct: bool,
        score: f32,
    },
    /// Aggregation phase started
    AggregationStarted,
    /// Solutions were aggregated
    SolutionsAggregated { result_solution_id: String },
    /// Improvement phase started
    ImprovementStarted { iteration: usize },
    /// Solution was improved
    SolutionImproved { solution_id: String },
    /// Strategy network phase started
    StrategyNetworkStarted,
    /// Strategy was extracted
    StrategyExtracted { strategy_id: String },
    /// Synthesis phase started
    SynthesisStarted,
    /// Final answer synthesized
    AnswerSynthesized { answer: String },
    /// MARS execution completed
    Completed { final_answer: String, method: String },
    /// Error occurred
    Error { message: String },
}
